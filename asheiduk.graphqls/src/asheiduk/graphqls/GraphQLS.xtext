/*
 * Modelled according to the specifiaction at
 *
 * https://graphql.github.io/graphql-spec/June2018/#sec-Type-System
 */
grammar asheiduk.graphqls.GraphQLS hidden (WS, SL_COMMENT, COMMA)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// TODO: othe URI (?)
generate graphQLS "http://www.graphqls.asheiduk/GraphQLS"

// ------------------------------------------------------------------------
// -- Document
// ------------------------------------------------------------------------

Document:
	definitions += Definition+
;

Definition:
	ObjectTypeDefinition
	| OperationDefinition
;

// ------------------------------------------------------------------------
// -- OperationDefinition
// ------------------------------------------------------------------------

OperationDefinition:
	'{' selectionSet += Selection+ '}'
;

Selection:
	(alias=ID ':')? field=ID Arguments<const=false>? Directives<const=false>?
;

// ------------------------------------------------------------------------
// -- TypeDefinition / TypeExtension
// ------------------------------------------------------------------------

ObjectTypeDefinition:
	// Grammar Ambiguities here: "type X { Y }" could be a type definition WITH a FieldDefinition 
	//	XOR a type definition WITHOUT a field followed by an anonymous query. Depending on the 
	// (assumed) lookahead Y could be "a : b" (either field-name "a" with type "b" XOR field "b" aliased as "a")
	'type' Name
	 ->
	FieldsDefinition?
;

fragment FieldsDefinition*:
	'{'
		fields += FieldDefinition+
	'}'
;

FieldDefinition:
	Name ArgumentsDefinition? ':' TypeSpec Directives<const=true>?
;

// ------------------------------------------------------------------------

fragment ArgumentsDefinition*:
	'(' arguments += InputValueDefinition+ ')'
;

InputValueDefinition:
	Name ':' TypeSpec Directives<const=true>?
;

// ------------------------------------------------------------------------

fragment Directives<const>*:
	directives += Directive<const>+
;

Directive<const>:
	'@' Name Arguments<const>?
;

fragment Arguments<const>*:
	'(' arguments += Argument<const>+ ')'	
;

Argument<const>:
	Name ':' value=Value<const>
;

// ------------------------------------------------------------------------

Value<const>:
	{IntValue} value=INT
	| {EnumValue} value=ID
	| {ObjectValue} '{' fields += ObjectField<const>* '}'	// Error changes if this is removed. Why?
;

ObjectField<const>:
	Name ':' value=Value<const>
;

// ------------------------------------------------------------------
// -- Grammar-Fragments
// ------------------------------------------------------------------

fragment Name*:
	name=ID
;

fragment TypeSpec*:
	type=ID
;

// ------------------------------------------------------------------
// -- Terminals
// ------------------------------------------------------------------

terminal INT returns ecore::EInt:
	'-'? '0' | '-'? '1'..'9' '0'..'9'*;

terminal fragment FRACTIONAL_PART:
	'.' '0'..'9'+;

terminal fragment EXPONENT_PART:
	('e' | 'E') ('+' | '-')? '0'..'9'+;

// TODO: align with spec
terminal STRING:
	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"'
	| '"""' -> '"""';

terminal ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

// -- hidden tokens

terminal SL_COMMENT : '#' !('\n'|'\r')* ('\r'? '\n')?;

terminal COMMA: ',';

terminal WS: (' '|'\t'|'\r'|'\n')+;

// terminal ANY_OTHER: .;
